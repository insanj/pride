"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Utils = require("./lib/Utils");

var FS = _interopRequireWildcard(require("fs"));

var path = _interopRequireWildcard(require("path"));

var mkdirp = _interopRequireWildcard(require("mkdirp"));

var _Errors = require("./lib/Errors");

var _DBParentData = require("./lib/DBParentData");

var _ArrayInfo = require("./lib/ArrayInfo");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class JsonDB {
  /**
   * JSONDB Constructor
   * @param filename where to save the "DB"
   * @param saveOnPush save the database at each push command into the json file
   * @param humanReadable the JSON file will be readable easily by a human
   */
  constructor(filename, saveOnPush = true, humanReadable = false) {
    _defineProperty(this, "filename", void 0);

    _defineProperty(this, "loaded", false);

    _defineProperty(this, "data", {});

    _defineProperty(this, "saveOnPush", true);

    _defineProperty(this, "humanReadable", void 0);

    this.filename = filename;

    if (!filename.endsWith(".json")) {
      this.filename += ".json";
    }

    this.saveOnPush = saveOnPush;
    this.humanReadable = humanReadable;

    if (!FS.existsSync(this.filename)) {
      const dirname = path.dirname(this.filename);
      mkdirp.sync(dirname);
      this.save(true);
      this.loaded = true;
    }
  }
  /**
   * Process datapath into different parts
   * @param dataPath
   */


  processDataPath(dataPath) {
    if (dataPath === undefined || !dataPath.trim()) {
      throw new _Errors.DataError("The Data Path can't be empty", 6);
    }

    if (dataPath == "/") {
      return [];
    }

    dataPath = (0, _Utils.removeTrailingSlash)(dataPath);
    const path = dataPath.split("/");
    path.shift();
    return path;
  }

  retrieveData(dataPath, create = false) {
    this.load();

    const recursiveProcessDataPath = (data, index) => {
      let property = dataPath[index];
      /**
       * Find the wanted Data or create it.
       */

      function findData(isArray = false) {
        if (data.hasOwnProperty(property)) {
          data = data[property];
        } else if (create) {
          if (isArray) {
            data[property] = [];
          } else {
            data[property] = {};
          }

          data = data[property];
        } else {
          throw new _Errors.DataError("Can't find dataPath: /" + dataPath.join("/") + ". Stopped at " + property, 5);
        }
      }

      const arrayInfo = _ArrayInfo.ArrayInfo.processArray(property);

      if (arrayInfo) {
        property = arrayInfo.property;
        findData(true);

        if (!Array.isArray(data)) {
          throw new _Errors.DataError("DataPath: /" + dataPath.join("/") + ". " + property + " is not an array.", 11);
        }

        const arrayIndex = arrayInfo.getIndex(data, true);

        if (!arrayInfo.append && data.hasOwnProperty(arrayIndex)) {
          data = data[arrayIndex];
        } else if (create) {
          if (arrayInfo.append) {
            data.push({});
            data = data[data.length - 1];
          } else {
            data[arrayIndex] = {};
            data = data[arrayIndex];
          }
        } else {
          throw new _Errors.DataError("DataPath: /" + dataPath.join("/") + ". Can't find index " + arrayInfo.index + " in array " + property, 10);
        }
      } else {
        findData();
      }

      if (dataPath.length == ++index) {
        return data;
      }

      return recursiveProcessDataPath(data, index);
    };

    if (dataPath.length === 0) {
      return this.data;
    }

    return recursiveProcessDataPath(this.data, 0);
  }

  getParentData(dataPath, create) {
    const path = this.processDataPath(dataPath);
    const last = path.pop();
    return new _DBParentData.DBParentData(this.retrieveData(path, create), this, dataPath, last);
  }
  /**
   * Get the wanted data
   * @param dataPath
   */


  getData(dataPath) {
    const path = this.processDataPath(dataPath);
    return this.retrieveData(path, false);
  }
  /**
   * Check for existing datapath
   * @param dataPath
   */


  exists(dataPath) {
    try {
      this.getData(dataPath);
      return true;
    } catch (e) {
      if (e instanceof _Errors.DataError) {
        return false;
      }

      throw e;
    }
  }
  /**
   * Find all specific entry in an array/object
   * @param rootPath base dataPath from where to start searching
   * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.
   */


  filter(rootPath, callback) {
    const result = this.getData(rootPath);

    if (Array.isArray(result)) {
      return result.filter(callback);
    }

    if (result instanceof Object) {
      const entries = Object.entries(result);
      const found = entries.filter(entry => {
        return callback(entry[1], entry[0]);
      });

      if (!found || found.length < 1) {
        return undefined;
      }

      return found.map(entry => {
        return entry[1];
      });
    }

    throw new _Errors.DataError("The entry at the path (" + rootPath + ") needs to be either an Object or an Array", 12);
  }
  /**
   * Find a specific entry in an array/object
   * @param rootPath base dataPath from where to start searching
   * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.
   */


  find(rootPath, callback) {
    const result = this.getData(rootPath);

    if (Array.isArray(result)) {
      return result.find(callback);
    }

    if (result instanceof Object) {
      const entries = Object.entries(result);
      const found = entries.find(entry => {
        return callback(entry[1], entry[0]);
      });

      if (!found || found.length < 2) {
        return undefined;
      }

      return found[1];
    }

    throw new _Errors.DataError("The entry at the path (" + rootPath + ") needs to be either an Object or an Array", 12);
  }
  /**
   * Pushing data into the database
   * @param dataPath path leading to the data
   * @param data data to push
   * @param override overriding or not the data, if not, it will merge them
   */


  push(dataPath, data, override = true) {
    const dbData = this.getParentData(dataPath, true);

    if (!dbData) {
      throw new Error("Data not found");
    }

    let toSet = data;

    if (!override) {
      if (Array.isArray(data)) {
        let storedData = dbData.getData();

        if (storedData === undefined) {
          storedData = [];
        } else if (!Array.isArray(storedData)) {
          throw new _Errors.DataError("Can't merge another type of data with an Array", 3);
        }

        toSet = storedData.concat(data);
      } else if (data === Object(data)) {
        if (Array.isArray(dbData.getData())) {
          throw new _Errors.DataError("Can't merge an Array with an Object", 4);
        }

        toSet = (0, _Utils.merge)(dbData.getData(), data);
      }
    }

    dbData.setData(toSet);

    if (this.saveOnPush) {
      this.save();
    }
  }
  /**
   * Delete the data
   * @param dataPath path leading to the data
   */


  delete(dataPath) {
    const dbData = this.getParentData(dataPath, true);

    if (!dbData) {
      return;
    }

    dbData.delete();

    if (this.saveOnPush) {
      this.save();
    }
  }
  /**
   * Only use this if you know what you're doing.
   * It reset the full data of the database.
   * @param data
   */


  resetData(data) {
    this.data = data;
  }
  /**
   * Reload the database from the file
   */


  reload() {
    this.loaded = false;
    this.load();
  }

  /**
   * Manually load the database
   * It is automatically called when the first getData is done
   */
  load() {
    if (this.loaded) {
      return;
    }

    try {
      const data = FS.readFileSync(this.filename, 'utf8');
      this.data = JSON.parse(data);
      this.loaded = true;
    } catch (err) {
      const error = new _Errors.DatabaseError("Can't Load Database", 1, err);
      throw error;
    }
  }
  /**
   * Manually save the database
   * By default you can't save the database if it's not loaded
   * @param force force the save of the database
   */


  save(force) {
    force = force || false;

    if (!force && !this.loaded) {
      throw new _Errors.DatabaseError("DataBase not loaded. Can't write", 7);
    }

    var data = "";

    try {
      if (this.humanReadable) {
        data = JSON.stringify(this.data, null, 4);
      } else {
        data = JSON.stringify(this.data);
      }

      FS.writeFileSync(this.filename, data, 'utf8');
    } catch (err) {
      var error = new _Errors.DatabaseError("Can't save the database", 2, err);
      throw error;
    }
  }

}

exports.default = JsonDB;
module.exports = exports.default;